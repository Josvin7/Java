<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>数据结构</title>
</head>
<body>
<div>
    1.	线性表<br />

    线性表(linear list)是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。<br />
    在稍复杂的线性表中，一个数据元素可由多个数据项(item)组成，此种情况下常把数据元素称为记录(record)，含有大量记录的线性表又称文件(file)。<br />
    线性表中的个数n定义为线性表的长度，n=0时称为空表。在非空表中每个数据元素都有一个确定的位置，如用ai表示数据元素，则i称为数据元素ai在线性表中的位序。<br />
    线性表的相邻元素之间存在着序偶关系。如用(a1，…，ai-1，ai，ai+1，…，an)表示一个顺序表，则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1,2，…，n-1时，ai有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱 。<br />
    线性表的特征：<br />
    （1）集合中必存在唯一的一个"第一元素"。<br />
    （2）集合中必存在唯一的一个 "最后元素" 。<br />
    （3）除最后一个元素之外，均有唯一的后继。<br />
    （4）除第一个元素之外，均有唯一的前驱。<br />
    线性表的存储结构：<br />
    线性表主要由顺序表示或链式表示。在实际应用中，常以栈、队列、字符串等特殊形式使用。<br />
    顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，称为线性表的顺序存储结构或顺序映像(sequential mapping)。它以"物理位置相邻"来表示线性表中数据元素间的逻辑关系，可随机存取表中任一元素。<br />
    链式表示指的是用一组任意的存储单元存储线性表中的数据元素，称为线性表的链式存储结构。它的存储单元可以是连续的，也可以是不连续的。在表示数据元素之间的逻辑关系时，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)，这两部分信息组成数据元素的存储映像，称为结点(node)。它包括两个域;存储数据元素信息的域称为数据域;存储直接后继存储位置的域称为指针域。指针域中存储的信息称为指针或链 。<br />
</div>

2.栈Stack<br />

栈是一种运算受限的线性表，是一种先进后出的数据结构，限定只能在一端进行插入和删除操作，允许操作的一端称为栈顶，不允许操作的称为栈底。Java API中栈继承于Vector类，也可以使用ArrayList和LinkedList来实现栈。栈是限制和插入只能在一个位置进行的表，这个位置为表的末端，叫做栈的顶(Top).栈也叫做后进先出表。栈顶的元素是唯一可见的元素。<br />
顺序栈（顺序结构）<br />
顺序栈：用一段连续的存储空间来存储栈中的数据元素，比较常见的是用数组来实现顺序栈<br />
顺序存储结构：（1）元素所占的存储空间必须连续（这里的连续是指的逻辑连续，而不是物理连续）<br />
（2）元素在存储空间的位置是按逻辑顺序存放的<br />
栈的操作一般有进栈(push)和出栈(pop)<br />



3. 队列Queue<br />
像栈一样，队列（queue）也是一种线性表，它的特性是先进先出，插入在一端，删除在另一端。就像排队一样，刚来的人入队（push）要排在队尾(rear)，每次出队(pop)的都是队首(front)的人。队列也是表，使用队列时插入在一端进行，而删除在另一端进行。可以使用数组实现也可以使用链表实现。<br />
队头与队尾： 允许元素插入的一端称为队尾，允许元素删除的一端称为队头。<br />
入队：队列的插入操作。<br />
出队：队列的删除操作。<br />
它具有如下特点：<br />
（1）队列中的数据元素遵循“先进先出”（First In First Out）的原则，简称FIFO结构。<br />
（2）在队尾添加元素，在队头删除元素。<br />

例如我们有一个存储整型元素的队列，我们依次入队：{1，2，3}<br />

添加元素时，元素只能从队尾一端进入队列，也即是2只能跟在1后面，3只能跟在2后面。<br />
如果队列中的元素要出队：<br />

元素只能从队首出队列，出队列的顺序为：1、2、3，与入队时的顺序一致，这就是所谓的“先进先出”。<br />


4.映射<br />
(1)散列(哈希):哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把散列码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。<br />
映射又分为散列映射和树映射：<br />
散列映射就是上面所介绍的根据散列码值映射唯一的value<br />
树映射指的是用键的整体顺序对元素进行排序，并将其组织成搜索树，最常用的实现类TreeMap<br />
(2)映射表（Map）:Map是一个接口，代表由关键字以及他们的值组成的一些项的集合。关键字必须是唯一的，但是若干个关键字可以映射到相同的值。因此值不必唯一。<br />
SorttedMap继承于Map接口，映射中的关键字保持逻辑上的<br />
有序状态，实现类是TreeMap<br />
Map接口没有实现Iterator迭代器，因此遍历Map接口一般使用foreach方法，并提供一个接受键和值得lanbda表达式。<br />
Map中的元素是无序的，它的实现类LinkedHashMap在里面维护了一个链表，用来记住插入元素项的顺序。<br />


5.图<br />
图在数据结构中是中一对多的关系，一般分为无向图与无向图，常用邻接矩阵或者邻接链表来表示图中结点的关系<br />
图是一个二元组G=(V,E）。V是非空有穷的顶点集合。E是图G中边的集合。<br />
有向图：图中的每条边都有方向（即带有箭头）。<br />
无向图：图中的每条边都没有方向。<br />
有向边：用尖括号来表示为&lta,b>。a是始点，b是终点。也被称为弧，a是弧尾，b是弧头。<br />
无向边：用圆括号表示为(a,b)。<br />

完全图：任意两个顶点之间都有边的图（有向图或无向图）。<br />
n个顶点的无向完全图有n*(n-1)/2条边；n个顶点的有向完全图有n*(n-1)条边。<br />
顶点的度：与这个顶点邻接的边条数。<br />
对于有向图还有入度和出度的概念：<br />
入度：以此顶点为终点的边的数目。<br />
出度：以此顶点为始点的边的数目。<br />
路径：两顶点之间所存在的通路。<br />
路径的长度：该路径上边的条数。<br />
回路（环）：起点和终点相同（重合）的路径。<br />
简单路径：除了顶点和终点可能相同外，其他顶点均不相同的路径。<br />
简单回路：一个回路内，起点和终点相同，但其他的顶点都不相同。也可理解为起点和终点相同的简单路径是简单回路。简单回路是简单路径的一个子集。<br />
连通：存在从顶点a到b的路径，则说明两顶点是连通的。<br />
连通无向图：无向图中，任意两顶点之间都相互连通。<br />
强连通有向图：有向图中任意两个顶点a、b，从a到b连通，并且从b到a也连通。（因为是有向边，所以从a到b，从b到a的路径都要求存在）<br />
子图：对于图G=(V,E)和G1=(V1,E1)，如果V1包含于V，并且E1包含于E，则称G1是G的一个子图。<br />
连通子图：原图可能不是连通图，但其一些子图是连通的，则这些子图称为原图的连通子图。（对于有向图，则称为强连通子图）<br />
极大连通子图（连通分量）：G1是原图G的一个连通子图，G1的顶点和边集合都已经不能扩充，是极大的。（如果再增加  顶点，就会不连通，也没有其他的边可加）。如果G本身连通，则只有一个连通分量，就是G本身。<br />
极大强连通子图（强连通分量）：这是对于有向图来说的，与无向图中的定义类似。<br />

图1中任意两个顶点都不是相互连通的，所以有3个强连通分量（3个顶点）。<br />
图2中包含两个强连通分量。顶点a总是与其自身连通，所以其本身就是一个强连通分量。<br />
图3包含3个强连通分量。<br />
图4 是强连通有向图，只有一个强连通分量（其自身）。<br />
带权图：图中的每条边都带有一个权值。<br />
网络：带有权值的连通无向图。<br />
图的遍历方法目前有深度优先搜索法和广度(宽度)优先搜索法两种算法。<br />
（1）深度优先搜索：从图G的某个顶点V0出发，访问V0，然后选择一个与V0相邻且没被访问过的顶点Vi访问，再从Vi出发选择一个与Vi相邻且未被访问的顶点Vj进行访问，依次继续。如果当前被访问过的顶点的所有邻接顶点都已被访问，则退回到已被访问的顶点序列中最后一个拥有未被访问的相邻顶点的顶点w，从w出发按同样的方法向前遍历，直到图中所有顶点都被访问。<br />
（2）广度优先搜索:首先访问初始点Vi，并将其标记为已访问过，接着访问Vi的所有未被访问过的邻接点Vi1,Vi2,…, Vin，并均标记已访问过，然后再按照Vi1,Vi2,…, Vin的次序，访问每一个顶点的所有未被访问过的邻接点，并均标记为已访问过，依次类推，直到图中所有和初始点vi有路径相通的顶点都被访问过为止。<br />
深度优先搜索利用栈，广度优先搜索利用队列<br />

上图的深度遍历： V0，V1，V2，V5，V4，V6，V3，V7<br />
上图广度遍历是：V0，V1，V3，V4，V2，V6，V5，V7<br />
6.树<br />
树的概念：<br />
（1）不包含任何结点的树称为空树。<br />
（2）父节点相同的两个结点互为兄弟结点。<br />
（3）没有子结点的结点称为叶结点，树中其余结点称为分支结点（也就是度不为0的结点）。<br />
（4）一个结点的子结点的个数称为该结点的度。<br />
（5）树中结点的最大层数称为树的高度。<br />
二叉树的性质：<br />
　　（1）二叉树第i层上的结点数目最多为2i-1(i≥1)。<br />
　　（2）深度为k的二叉树至多有2^k-1个结点(k≥1)<br />
　　（3）在任意-棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则no=n2+1<br />
　　（4）具有n个结点的完全二叉树的深度为：log2[n](向下）+1或log2[n+1](向上）<br />
满二叉树：如果二叉树中的所有分支结点的度数都是2，则称其为满二叉树。<br />
此外，满二叉树中叶结点比分支结点多一个。<br />

完全二叉树：除了最后一层外，其他层的结点数都是满的，且最后一层的所有结点都在最左边连续排列，空位都在右边。<br />

如果一棵完全二叉树的结点总数为n，当n为偶数时，其叶子结点数为n/2个，当n为奇数时，其叶子结点数为（n+1）/2个。<br />
7.链表<br />
链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。链表中的每个元素都包含一个称为结点的结构。每个结点与它的相邻结点相连接。每个结点都包含元素和一个名为next的数据域，next指向下一个元素，如果结点是线性表中的最后一个，那么它的指针数据域next的值为null。<br />
线性表的链式存储表示的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素 与其直接后继数据元素 之间的逻辑关系，对数据元素 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。由这两部分信息组成一个结点（如概述旁的图所示），表示线性表中一个数据元素。线性表的链式存储表示，有一个缺点就是要找一个数，必须要从头开始找起。<br />
单链表包含一个指向线性表第一个结点的指针，只有一个方向的链接，即使增加了尾结点的引用，也只能支持O(1)时间的表头、表尾插入和O(1)时间的表头删除。<br />
如果希望两端插入和删除都变得高效，需要增加另一方向的链接，这就得到了双向链接表，简称双链表。这样做也会付出代价，每个结点都需要增加一个链接域，增加的空间开销与结点数成正比，是O(n)。但是，如果每个表结点里的数据规模比较大，新增加的开销可能就显得不太重要了。<br />
双向链表：包含两个指针的结点，一个指针指向下一个结点，另一个指针指向上一个结点，分别称为前指针和后指针。从双链表的任一结点出发，可以直接找到其前后的相邻结点，都是O(1)操作。而对于单链表而言，只能方便地找到下一结点，如果要找前一结点，则必须从表头开始再向后依次遍历。<br />

</body>
</html>